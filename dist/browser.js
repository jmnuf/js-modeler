!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("MyLibrary",[],t):"object"==typeof exports?exports.MyLibrary=t():e.MyLibrary=t()}(this,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var l in n)e.o(n,l)&&!e.o(t,l)&&Object.defineProperty(t,l,{enumerable:!0,get:n[l]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>i});class n extends TypeError{constructor(e,t){super("Invalid value(s) used to instance Model<"+e+"> -> "+t.join(", "));const n=t.splice(0);Object.defineProperties(this,{model_name:{get:()=>e},invalid_values:{get:()=>n}})}values(){return this.invalid_values.join(", ")}}function l(e,t){const l={},u=new Map,a=Object.keys(t),r=function(e,t,n,l){const u={};for(const a of n){if("object"!=typeof t[a]||null==t[a])continue;const n=e[a];if("function"!=typeof n){if(u[a]=n.default_value,!n.nullable&&"object"==n.base_type)if(n.Model){const e=n.Model;Object.defineProperty(u,a,{get:()=>e.instance()})}else if(n.Class){const e=n.Class;Object.defineProperty(u,a,{get:()=>new e})}}else l.set(a,n)}return u}(t,l,a,u),i=function(e,t,l){return class extends class{}{constructor(u){super();const a=Object.keys(u),r=[];for(const e of l){const n=t[e];if("function"==typeof n){this[e]=n;continue}if(!a.includes(e)){this[e]=n.default_value,n.required&&r.push("Invalid data: Missing required key "+e);continue}const l=u[e],i=n.validation(l);if(i.valid)this[e]=i.value;else{const t=`Invalid key '${e}': ${i.value}`;r.push(t)}}if(r.length>0)throw new n(e,r);return this}}}(e,l,a);Object.defineProperties(i,{instance:{get:()=>function(){return new i(r)}},name:{get:()=>e},defaults:{get:()=>r}});const o=u.keys();for(const e of o)i.prototype[e]=u.get(e);return i}function u(e,t,n,l){return{get base_type(){return e},get required(){return t},get default_value(){return l},nullable:n,validation(t){const n=this.base_type,l={valid:!0,value:t};if("any"==n)return l;const u=typeof t;return u!=n&&(l.valid=!1,l.value="Types don't align expected `"+e+"` but got `"+u+"`"),l}}}const a=l("StructSettings",{required:u("boolean",!1,!1,!0),default_value:u("any",!0,!0,void 0),nullable:u("boolean",!1,!1,!0)});function r(e,t,n=!0){const l=Object.assign({nullable:n,required:!0,default_value:t},e);return l.nullable&&!("default_value"in e)&&(l.default_value=null),new a(l)}const i={createModel:l,Structs:{int(e={}){const t=r(e,0,!1),n=u("number",t.required,t.nullable,t.default_value),l=n.validation.bind(n);return n.validation=function(e){const t=l(e);return t.valid&&(Number.isInteger(t.value)||(t.valid=!1,t.value="Types don't fully align expected an integer number but got a floating point number")),t},n},number(e={}){const t=r(e,0,!1);return u("number",t.required,t.nullable,t.default_value)},string(e={}){const t=r(e,"",!1);return u("string",t.required,t.nullable,t.default_value)},model(e,t={}){if(!e)throw new TypeError("Passed model class must be a valid model that inherits from JsModel");const n=r(t,null),l=u("object",n.required,n.nullable,n.default_value),a=l.validation.bind(l);return l.Model=e,l.validation=function(t){const l=a(t);if(l.valid){if(null==l.value)return n.nullable||(l.valid=!1,l.value="Value can't be null"),l;try{const n=new e(t);l.value=n}catch(e){l.valid=!1,l.value=e.message}}return l},l},bigint(e={}){const t=r(e,BigInt(0),!1);return u("bigint",t.required,t.nullable,t.default_value)},bool(e={}){const t=r(e,!1,!1);return u("boolean",t.required,t.nullable,t.default_value)},map(e={}){const t=r(e,new Map,!1),n=u("object",t.required,t.nullable,t.default_value),l=n.validation.bind(n);return n.Class=Map,n.validation=function(e){const n=l(e);if(n.valid){if(null==n.value)return t.nullable||(n.valid=!1,n.value="Value can't be null"),n;const e=Object.entries(n.value);n.value=new Map(e)}return n},n}}};return t.default})()));